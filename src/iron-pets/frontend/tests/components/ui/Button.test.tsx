// Generated by qe-test-writer subagent
// TDD RED Phase - All tests define expected behavior
// Module: src/components/ui/Button.tsx
// Test Coverage: 52 comprehensive test cases covering all requirements

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button } from '@/components/ui/Button';
import { createRef } from 'react';

describe('Button Component - Comprehensive Test Suite', () => {
  // ============================================================================
  // SECTION 1: RENDERING TESTS (8 tests)
  // ============================================================================
  describe('Rendering', () => {
    test('should render with default props', () => {
      // GIVEN: A Button with no props
      render(<Button>Click me</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button', { name: /click me/i });

      // THEN: Button renders with default variant (primary) and size (md)
      expect(button).toBeInTheDocument();
      expect(button).toHaveClass('bg-primary');
      expect(button).toHaveClass('px-4');
      expect(button).toHaveClass('py-2');
    });

    test('should render with custom className', () => {
      // GIVEN: A Button with custom className
      render(<Button className="custom-class">Button</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Custom className is applied along with base classes
      expect(button).toHaveClass('custom-class');
      expect(button).toHaveClass('inline-flex'); // Base class
    });

    test('should render children content correctly', () => {
      // GIVEN: A Button with complex children
      render(
        <Button>
          <span>Icon</span>
          <span>Label</span>
        </Button>
      );

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: All children are rendered
      expect(button).toHaveTextContent('Icon');
      expect(button).toHaveTextContent('Label');
    });

    test('should apply correct display name', () => {
      // GIVEN: A Button component
      // WHEN: Checking component metadata
      // THEN: Display name is 'Button'
      expect(Button.displayName).toBe('Button');
    });

    test('should render as button element by default', () => {
      // GIVEN: A Button without type attribute
      render(<Button>Default Button</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: It renders as a button element
      expect(button.tagName).toBe('BUTTON');
    });

    test('should render with data-testid attribute', () => {
      // GIVEN: A Button with data-testid
      render(<Button data-testid="custom-button">Test</Button>);

      // WHEN: The button is rendered
      const button = screen.getByTestId('custom-button');

      // THEN: data-testid is accessible
      expect(button).toBeInTheDocument();
    });

    test('should render empty button without children', () => {
      // GIVEN: A Button with no children
      render(<Button />);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Button renders but is empty
      expect(button).toBeInTheDocument();
      expect(button.textContent?.trim()).toBe('');
    });

    test('should render with complex JSX children', () => {
      // GIVEN: A Button with nested JSX
      render(
        <Button>
          <div>
            <strong>Bold</strong>
            <em>Italic</em>
          </div>
        </Button>
      );

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Complex children render correctly
      expect(button.querySelector('strong')).toHaveTextContent('Bold');
      expect(button.querySelector('em')).toHaveTextContent('Italic');
    });
  });

  // ============================================================================
  // SECTION 2: VARIANT TESTS (8 tests)
  // ============================================================================
  describe('Variants', () => {
    test('should apply primary variant styles', () => {
      // GIVEN: A Button with primary variant
      render(<Button variant="primary">Primary</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Primary variant classes are applied
      expect(button).toHaveClass('bg-primary');
      expect(button).toHaveClass('text-white');
      expect(button).toHaveClass('hover:bg-primary/90');
      expect(button).toHaveClass('focus:ring-primary');
    });

    test('should apply secondary variant styles', () => {
      // GIVEN: A Button with secondary variant
      render(<Button variant="secondary">Secondary</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Secondary variant classes are applied
      expect(button).toHaveClass('bg-gray-200');
      expect(button).toHaveClass('text-gray-900');
      expect(button).toHaveClass('hover:bg-gray-300');
      expect(button).toHaveClass('focus:ring-gray-400');
    });

    test('should apply outline variant styles', () => {
      // GIVEN: A Button with outline variant
      render(<Button variant="outline">Outline</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Outline variant classes are applied
      expect(button).toHaveClass('border-2');
      expect(button).toHaveClass('border-primary');
      expect(button).toHaveClass('text-primary');
      expect(button).toHaveClass('hover:bg-primary/10');
    });

    test('should apply ghost variant styles', () => {
      // GIVEN: A Button with ghost variant
      render(<Button variant="ghost">Ghost</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Ghost variant classes are applied
      expect(button).toHaveClass('text-gray-700');
      expect(button).toHaveClass('hover:bg-gray-100');
      expect(button).toHaveClass('focus:ring-gray-400');
    });

    test('should default to primary variant when not specified', () => {
      // GIVEN: A Button without variant prop
      render(<Button>Default Variant</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Primary variant is applied by default
      expect(button).toHaveClass('bg-primary');
      expect(button).toHaveClass('text-white');
    });

    test('should handle variant prop change', () => {
      // GIVEN: A Button that changes variant
      const { rerender } = render(<Button variant="primary">Button</Button>);

      // WHEN: Variant is changed to secondary
      rerender(<Button variant="secondary">Button</Button>);

      // THEN: New variant classes are applied
      const button = screen.getByRole('button');
      expect(button).toHaveClass('bg-gray-200');
      expect(button).not.toHaveClass('bg-primary');
    });

    test('should apply variant-specific focus ring colors', () => {
      // GIVEN: Buttons with different variants
      const { container: primary } = render(<Button variant="primary">Primary</Button>);
      const { container: secondary } = render(<Button variant="secondary">Secondary</Button>);

      // WHEN: Checking focus ring classes
      const primaryBtn = primary.querySelector('button');
      const secondaryBtn = secondary.querySelector('button');

      // THEN: Each variant has correct focus ring color
      expect(primaryBtn).toHaveClass('focus:ring-primary');
      expect(secondaryBtn).toHaveClass('focus:ring-gray-400');
    });

    test('should combine variant with base styles', () => {
      // GIVEN: A Button with any variant
      render(<Button variant="outline">Combined</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Base styles and variant styles coexist
      expect(button).toHaveClass('inline-flex'); // Base
      expect(button).toHaveClass('rounded-lg'); // Base
      expect(button).toHaveClass('border-2'); // Variant
      expect(button).toHaveClass('border-primary'); // Variant
    });
  });

  // ============================================================================
  // SECTION 3: SIZE TESTS (6 tests)
  // ============================================================================
  describe('Sizes', () => {
    test('should apply small size styles', () => {
      // GIVEN: A Button with sm size
      render(<Button size="sm">Small</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Small size classes are applied
      expect(button).toHaveClass('px-3');
      expect(button).toHaveClass('py-1.5');
      expect(button).toHaveClass('text-sm');
    });

    test('should apply medium size styles', () => {
      // GIVEN: A Button with md size
      render(<Button size="md">Medium</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Medium size classes are applied
      expect(button).toHaveClass('px-4');
      expect(button).toHaveClass('py-2');
      expect(button).toHaveClass('text-base');
    });

    test('should apply large size styles', () => {
      // GIVEN: A Button with lg size
      render(<Button size="lg">Large</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Large size classes are applied
      expect(button).toHaveClass('px-6');
      expect(button).toHaveClass('py-3');
      expect(button).toHaveClass('text-lg');
    });

    test('should default to medium size when not specified', () => {
      // GIVEN: A Button without size prop
      render(<Button>Default Size</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Medium size is applied by default
      expect(button).toHaveClass('px-4');
      expect(button).toHaveClass('py-2');
      expect(button).toHaveClass('text-base');
    });

    test('should handle size prop change', () => {
      // GIVEN: A Button that changes size
      const { rerender } = render(<Button size="sm">Button</Button>);

      // WHEN: Size is changed to lg
      rerender(<Button size="lg">Button</Button>);

      // THEN: New size classes are applied
      const button = screen.getByRole('button');
      expect(button).toHaveClass('px-6');
      expect(button).not.toHaveClass('px-3');
    });

    test('should combine size with variant styles', () => {
      // GIVEN: A Button with both size and variant
      render(
        <Button size="lg" variant="secondary">
          Large Secondary
        </Button>
      );

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Both size and variant classes are applied
      expect(button).toHaveClass('px-6'); // Size
      expect(button).toHaveClass('py-3'); // Size
      expect(button).toHaveClass('bg-gray-200'); // Variant
      expect(button).toHaveClass('text-gray-900'); // Variant
    });
  });

  // ============================================================================
  // SECTION 4: STATE TESTS (10 tests)
  // ============================================================================
  describe('States', () => {
    test('should apply disabled state correctly', () => {
      // GIVEN: A disabled Button
      render(<Button disabled>Disabled</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Disabled attribute and styles are applied
      expect(button).toBeDisabled();
      expect(button).toHaveClass('disabled:opacity-50');
      expect(button).toHaveClass('disabled:pointer-events-none');
    });

    test('should show loading spinner when isLoading is true', () => {
      // GIVEN: A Button with isLoading prop
      render(<Button isLoading>Loading</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Loading spinner is visible
      const spinner = button.querySelector('.animate-spin');
      expect(spinner).toBeInTheDocument();
      expect(spinner).toHaveClass('mr-2');
      expect(spinner).toHaveClass('h-4');
      expect(spinner).toHaveClass('w-4');
    });

    test('should disable button when isLoading is true', () => {
      // GIVEN: A Button with isLoading prop
      render(<Button isLoading>Loading</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Button is disabled
      expect(button).toBeDisabled();
    });

    test('should apply focus ring on focus', () => {
      // GIVEN: A Button that receives focus
      render(<Button>Focus Me</Button>);

      // WHEN: Button is focused
      const button = screen.getByRole('button');
      button.focus();

      // THEN: Focus ring classes are present
      expect(button).toHaveClass('focus:outline-none');
      expect(button).toHaveClass('focus:ring-2');
      expect(button).toHaveClass('focus:ring-offset-2');
      expect(button).toHaveFocus();
    });

    test('should maintain hover state styles', () => {
      // GIVEN: A Button with hover capability
      render(<Button variant="primary">Hover Me</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Hover classes are present
      expect(button).toHaveClass('hover:bg-primary/90');
      expect(button).toHaveClass('transition-colors');
    });

    test('should handle combined disabled and isLoading states', () => {
      // GIVEN: A Button with both disabled and isLoading
      render(
        <Button disabled isLoading>
          Disabled Loading
        </Button>
      );

      // WHEN: The button is rendered
      const button = screen.getByRole('button');
      const spinner = button.querySelector('.animate-spin');

      // THEN: Both states are applied
      expect(button).toBeDisabled();
      expect(spinner).toBeInTheDocument();
      expect(button).toHaveClass('disabled:opacity-50');
    });

    test('should show children alongside loading spinner', () => {
      // GIVEN: A loading Button with children
      render(<Button isLoading>Save Changes</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Both spinner and children are visible
      expect(button.querySelector('.animate-spin')).toBeInTheDocument();
      expect(button).toHaveTextContent('Save Changes');
    });

    test('should not apply disabled styles when only loading', () => {
      // GIVEN: A Button with isLoading but not disabled prop
      render(<Button isLoading>Loading</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Button is disabled but via isLoading, not disabled prop
      expect(button).toBeDisabled();
      expect(button.getAttribute('disabled')).not.toBeNull();
    });

    test('should maintain base styles in all states', () => {
      // GIVEN: Buttons in different states
      const { container: normal } = render(<Button>Normal</Button>);
      const { container: disabled } = render(<Button disabled>Disabled</Button>);
      const { container: loading } = render(<Button isLoading>Loading</Button>);

      // WHEN: Checking base classes
      const normalBtn = normal.querySelector('button');
      const disabledBtn = disabled.querySelector('button');
      const loadingBtn = loading.querySelector('button');

      // THEN: All maintain base styling classes
      [normalBtn, disabledBtn, loadingBtn].forEach((btn) => {
        expect(btn).toHaveClass('inline-flex');
        expect(btn).toHaveClass('items-center');
        expect(btn).toHaveClass('justify-center');
        expect(btn).toHaveClass('rounded-lg');
      });
    });

    test('should handle rapid state changes', async () => {
      // GIVEN: A Button that changes state rapidly
      const { rerender } = render(<Button>Initial</Button>);

      // WHEN: State changes multiple times quickly
      rerender(<Button disabled>Disabled</Button>);
      rerender(<Button isLoading>Loading</Button>);
      rerender(<Button>Normal</Button>);

      // THEN: Final state is rendered correctly
      const button = screen.getByRole('button');
      expect(button).not.toBeDisabled();
      expect(button.querySelector('.animate-spin')).not.toBeInTheDocument();
    });
  });

  // ============================================================================
  // SECTION 5: INTERACTION TESTS (8 tests)
  // ============================================================================
  describe('Interactions', () => {
    test('should call onClick handler when clicked', async () => {
      // GIVEN: A Button with onClick handler
      const handleClick = jest.fn();
      const user = userEvent.setup();
      render(<Button onClick={handleClick}>Click Me</Button>);

      // WHEN: Button is clicked
      const button = screen.getByRole('button');
      await user.click(button);

      // THEN: onClick handler is called once
      expect(handleClick).toHaveBeenCalledTimes(1);
    });

    test('should not call onClick when disabled', async () => {
      // GIVEN: A disabled Button with onClick handler
      const handleClick = jest.fn();
      const user = userEvent.setup();
      render(
        <Button onClick={handleClick} disabled>
          Disabled
        </Button>
      );

      // WHEN: Attempting to click the button
      const button = screen.getByRole('button');
      await user.click(button);

      // THEN: onClick handler is not called
      expect(handleClick).not.toHaveBeenCalled();
    });

    test('should not call onClick when loading', async () => {
      // GIVEN: A loading Button with onClick handler
      const handleClick = jest.fn();
      const user = userEvent.setup();
      render(
        <Button onClick={handleClick} isLoading>
          Loading
        </Button>
      );

      // WHEN: Attempting to click the button
      const button = screen.getByRole('button');
      await user.click(button);

      // THEN: onClick handler is not called
      expect(handleClick).not.toHaveBeenCalled();
    });

    test('should respond to keyboard Enter key', async () => {
      // GIVEN: A Button with onClick handler
      const handleClick = jest.fn();
      const user = userEvent.setup();
      render(<Button onClick={handleClick}>Keyboard</Button>);

      // WHEN: Enter key is pressed while focused
      const button = screen.getByRole('button');
      button.focus();
      await user.keyboard('{Enter}');

      // THEN: onClick handler is called
      expect(handleClick).toHaveBeenCalledTimes(1);
    });

    test('should respond to keyboard Space key', async () => {
      // GIVEN: A Button with onClick handler
      const handleClick = jest.fn();
      const user = userEvent.setup();
      render(<Button onClick={handleClick}>Keyboard</Button>);

      // WHEN: Space key is pressed while focused
      const button = screen.getByRole('button');
      button.focus();
      await user.keyboard(' ');

      // THEN: onClick handler is called
      expect(handleClick).toHaveBeenCalledTimes(1);
    });

    test('should handle rapid click events', async () => {
      // GIVEN: A Button with onClick handler
      const handleClick = jest.fn();
      const user = userEvent.setup();
      render(<Button onClick={handleClick}>Rapid Click</Button>);

      // WHEN: Button is clicked rapidly multiple times
      const button = screen.getByRole('button');
      await user.tripleClick(button);

      // THEN: All clicks are registered (no built-in debounce)
      expect(handleClick).toHaveBeenCalledTimes(3);
    });

    test('should pass event object to onClick handler', async () => {
      // GIVEN: A Button with onClick handler
      const handleClick = jest.fn();
      const user = userEvent.setup();
      render(<Button onClick={handleClick}>Event Test</Button>);

      // WHEN: Button is clicked
      const button = screen.getByRole('button');
      await user.click(button);

      // THEN: Event object is passed to handler
      expect(handleClick).toHaveBeenCalledWith(expect.any(Object));
      expect(handleClick.mock.calls[0][0]).toHaveProperty('target');
    });

    test('should handle mouse events correctly', async () => {
      // GIVEN: A Button with mouse event handlers
      const handleMouseEnter = jest.fn();
      const handleMouseLeave = jest.fn();
      const user = userEvent.setup();
      render(
        <Button onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>
          Hover
        </Button>
      );

      // WHEN: Mouse enters and leaves
      const button = screen.getByRole('button');
      await user.hover(button);
      await user.unhover(button);

      // THEN: Event handlers are called
      expect(handleMouseEnter).toHaveBeenCalledTimes(1);
      expect(handleMouseLeave).toHaveBeenCalledTimes(1);
    });
  });

  // ============================================================================
  // SECTION 6: ACCESSIBILITY TESTS (6 tests)
  // ============================================================================
  describe('Accessibility', () => {
    test('should have correct button role', () => {
      // GIVEN: A Button component
      render(<Button>Accessible</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: It has the button role
      expect(button).toBeInTheDocument();
    });

    test('should apply aria-disabled when disabled', () => {
      // GIVEN: A disabled Button
      render(<Button disabled>Disabled</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: aria-disabled is present
      expect(button).toBeDisabled();
      expect(button).toHaveAttribute('disabled');
    });

    test('should indicate loading state for screen readers', () => {
      // GIVEN: A loading Button
      render(<Button isLoading>Loading</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Button is disabled and spinner provides visual feedback
      expect(button).toBeDisabled();
      expect(button.querySelector('.animate-spin')).toBeInTheDocument();
    });

    test('should be focusable via keyboard navigation', () => {
      // GIVEN: Multiple buttons in sequence
      render(
        <div>
          <Button>First</Button>
          <Button>Second</Button>
          <Button>Third</Button>
        </div>
      );

      // WHEN: Tabbing through buttons
      const buttons = screen.getAllByRole('button');

      // THEN: Buttons are keyboard accessible
      buttons[0].focus();
      expect(buttons[0]).toHaveFocus();

      // Tab to next button (simulated)
      buttons[1].focus();
      expect(buttons[1]).toHaveFocus();
    });

    test('should not be focusable when disabled', () => {
      // GIVEN: A disabled Button
      render(<Button disabled>Disabled</Button>);

      // WHEN: Attempting to focus the button
      const button = screen.getByRole('button');
      button.focus();

      // THEN: Button does not receive focus (pointer-events-none)
      expect(button).toBeDisabled();
      expect(button).toHaveClass('disabled:pointer-events-none');
    });

    test('should support aria-label for screen readers', () => {
      // GIVEN: A Button with aria-label
      render(<Button aria-label="Close dialog">X</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button', { name: /close dialog/i });

      // THEN: aria-label is accessible
      expect(button).toHaveAttribute('aria-label', 'Close dialog');
    });
  });

  // ============================================================================
  // SECTION 7: HTML ATTRIBUTES TESTS (4 tests)
  // ============================================================================
  describe('HTML Attributes', () => {
    test('should support type attribute variations', () => {
      // GIVEN: Buttons with different type attributes
      const { container: button } = render(<Button type="button">Button</Button>);
      const { container: submit } = render(<Button type="submit">Submit</Button>);
      const { container: reset } = render(<Button type="reset">Reset</Button>);

      // WHEN: The buttons are rendered
      const buttonEl = button.querySelector('button');
      const submitEl = submit.querySelector('button');
      const resetEl = reset.querySelector('button');

      // THEN: Each has correct type attribute
      expect(buttonEl).toHaveAttribute('type', 'button');
      expect(submitEl).toHaveAttribute('type', 'submit');
      expect(resetEl).toHaveAttribute('type', 'reset');
    });

    test('should support form attribute for external form association', () => {
      // GIVEN: A Button with form attribute
      render(<Button form="external-form">Submit</Button>);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: form attribute is applied
      expect(button).toHaveAttribute('form', 'external-form');
    });

    test('should passthrough data-testid attribute', () => {
      // GIVEN: A Button with data-testid
      render(<Button data-testid="custom-test-id">Test</Button>);

      // WHEN: The button is rendered
      const button = screen.getByTestId('custom-test-id');

      // THEN: data-testid is accessible
      expect(button).toBeInTheDocument();
      expect(button).toHaveAttribute('data-testid', 'custom-test-id');
    });

    test('should forward ref to button element', () => {
      // GIVEN: A Button with ref
      const ref = createRef<HTMLButtonElement>();
      render(<Button ref={ref}>Ref Button</Button>);

      // WHEN: The button is rendered
      // THEN: Ref is forwarded correctly
      expect(ref.current).toBeInstanceOf(HTMLButtonElement);
      expect(ref.current).toHaveTextContent('Ref Button');
    });
  });

  // ============================================================================
  // ADDITIONAL EDGE CASE TESTS (2 tests)
  // ============================================================================
  describe('Edge Cases', () => {
    test('should handle missing children gracefully', () => {
      // GIVEN: A Button with no children
      render(<Button />);

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: Button renders without errors
      expect(button).toBeInTheDocument();
      expect(button.textContent?.trim()).toBe('');
    });

    test('should handle multiple className applications', () => {
      // GIVEN: A Button with multiple custom classes
      render(
        <Button className="custom-1 custom-2 custom-3" variant="outline" size="lg">
          Multi-Class
        </Button>
      );

      // WHEN: The button is rendered
      const button = screen.getByRole('button');

      // THEN: All classes are applied correctly
      expect(button).toHaveClass('custom-1');
      expect(button).toHaveClass('custom-2');
      expect(button).toHaveClass('custom-3');
      expect(button).toHaveClass('border-2'); // Variant
      expect(button).toHaveClass('px-6'); // Size
      expect(button).toHaveClass('inline-flex'); // Base
    });
  });
});

// Expected Result: ALL TESTS SHOULD PASS with the current Button implementation
// Test Coverage: 52 comprehensive test cases covering all requirements
// Next Step: Run tests with `npm test Button.test.tsx` to validate implementation
